package pharoslabut.logger.analyzer.ssvd;

import java.io.*;
import java.util.*;
import pharoslabut.logger.*;
import pharoslabut.logger.analyzer.*;

/**
 * Reads the output generated by pharoslabut.logger.analyzer.SignalStrengthVsDist. 
 * Calculates averages and confidence intervals over one meter distance intervals.
 * 
 * @author Chien-Liang Fok
 * @see pharoslabut.logger.analyzer.SignalStrengthVsDist
 */
public class TelosBSSvDAvgGenerator {
	
	/**
	 * The interval in meters over which to calculate the average signal strength.
	 */
	public static final int AVERAGE_WINDOW_SIZE = 5;
	
	/**
	 * The confidence interval expressed as a percentage.
	 */
	public static final int CONFIDENCE_INTERVAL = 95;
	public static final double Z_VALUE = 1.96; // this corresponds to 95$ confidence interval
	
	private FileLogger flogger = null;
	
	
	/**
	 * The constructor.
	 * 
	 * @param inputFile The directory containing the data from the experiment.
	 * @param flogger The file logger in which to save log data. This may be null.
	 */
	public TelosBSSvDAvgGenerator(FileLogger flogger) {
		this.flogger = flogger;
		
	}
	
	/**
	 * Generates the average and confidence interval.
	 * 
	 * @param inputFileName
	 * @param outputFileName
	 */
	public void generateAverage(String inputFileName, String outputFileName) {
		
		log("Input file: " + inputFileName);
		// First read the input file
		BufferedReader input = null;
		try {
			input =  new BufferedReader(new FileReader(inputFileName));
		} catch (IOException ex){
			ex.printStackTrace();
			System.err.println("Unable to open " + inputFileName);
			System.exit(1);
		}
		
		Vector<String> comments = new Vector<String>();
		Vector<TelosBSignalStrengthResult> data = new Vector<TelosBSignalStrengthResult>();
		
		try {
			String line = null;
			int lineno = 1;
			while (( line = input.readLine()) != null) {
				//log("Line: " + line);
				if (!line.equals("")) { // ignore blank lines
					if (line.startsWith("#")) {
						comments.add(line);
//						log("Adding comment: " + line);
					}
					else if (!line.contains("Timestamp")) { // ignore the header
						String[] elem = line.split("[\\s]+");
						long timestamp = Long.valueOf(elem[0]);
						int sndrID = Integer.valueOf(elem[1]);
						int rcvrID = Integer.valueOf(elem[2]);
						int seqno = Integer.valueOf(elem[3]);
						double dist = Double.valueOf(elem[4]);
						int lqi = Integer.valueOf(elem[5]);
						int rssi = Integer.valueOf(elem[6]);
						
						TelosBRxRecord rxRecord = new TelosBRxRecord(timestamp, rcvrID, sndrID, seqno, rssi, lqi) ;
						TelosBSignalStrengthResult result = new TelosBSignalStrengthResult(rxRecord, dist);
						data.add(result);
					}
				}
				lineno++;
			}
			input.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		if (data.size() == 0) {
			logErr("No data found!");
			System.exit(0);
		}
		
		double maxDist = findMaxDist(data);
		log("maxDist = " + maxDist);
		
		// Create a bucket for each distance interval
		Hashtable<Integer, Vector<TelosBSignalStrengthResult>> buckets = new Hashtable<Integer, Vector<TelosBSignalStrengthResult>>();
		for (int i=0; i < maxDist; i += AVERAGE_WINDOW_SIZE) {
			buckets.put(i, new Vector<TelosBSignalStrengthResult>());
		}
		
		// split the data into the buckets
		Enumeration<TelosBSignalStrengthResult> e = data.elements();
		while (e.hasMoreElements()) {
			TelosBSignalStrengthResult r = e.nextElement();
			insertIntoBucket(r, buckets);
		}
		
		// Determine the names of the two files in which to store the output data
		// This is needed because gnuplot expects the data to be in three columns:
		// [x val], [y val], [y error].  Thus, we need to divide the RSSI and LQI 
		// values into two different files.
		String outputFileNameRSSI = null;
		String outputFileNameLQI = null;
		if (outputFileName.indexOf(".") != -1) {
			String prefix = outputFileName.substring(0, outputFileName.indexOf("."));
			String suffix = outputFileName.substring(outputFileName.indexOf("."));
			outputFileNameRSSI = prefix + "-RSSI" + suffix;
			outputFileNameLQI = prefix + "-LQI" + suffix;
		} else {
			outputFileNameRSSI = outputFileName + "-RSSI";
			outputFileNameLQI = outputFileName + "-LQI";
		}
		
		FileLogger outFlogger = new FileLogger(outputFileNameRSSI, false);
		
		// for debugging output
//		printBuckets(buckets, outFlogger);
		
		// Print the comments and the table header
		for (int i=0; i < comments.size(); i++) {
			outFlogger.log(comments.get(i));
		}
		print("# Average distances and RSSI values, Distance Window Size = " + AVERAGE_WINDOW_SIZE + ", Confidence Interval = " + CONFIDENCE_INTERVAL + "%", outFlogger);
		print("# Average Distance\tAverage RSSI (dBm)\tRSSI Confidence", outFlogger);
		
		// For each bucket, calculate the average distance and RSSI values 
		// and their confidence intervals 
		for (int i=0; i < maxDist; i += AVERAGE_WINDOW_SIZE) {
			Vector<TelosBSignalStrengthResult> currBucket = buckets.get(i);
			if (currBucket.size() > 0) {
				double avgDist = calcAvgDist(currBucket);
				double avgRSSI = calcAvgRSSI(currBucket);
				double confRSSI = calcConfRSSI(currBucket, avgRSSI);
				print(avgDist + "\t" + avgRSSI + "\t" + confRSSI, outFlogger);
			}
		}
		
		
		outFlogger = new FileLogger(outputFileNameLQI, false);
		
		// for debugging output
//		printBuckets(buckets, outFlogger);
		
		// Print the comments and the table header
		for (int i=0; i < comments.size(); i++) {
			outFlogger.log(comments.get(i));
		}
		print("# Average distances and LQI values, Distance Window Size = " + AVERAGE_WINDOW_SIZE + ", Confidence Interval = " + CONFIDENCE_INTERVAL + "%", outFlogger);
		print("# Average Distance\tAverage LQI\tLQI Confidence", outFlogger);
		
		// For each bucket, calculate the average distance and LQI values 
		// and their confidence intervals 
		for (int i=0; i < maxDist; i += AVERAGE_WINDOW_SIZE) {
			Vector<TelosBSignalStrengthResult> currBucket = buckets.get(i);
			if (currBucket.size() > 0) {
				double avgDist = calcAvgDist(currBucket);
				double avgLQI = calcAvgLQI(currBucket);
				double confLQI = calcConfLQI(currBucket, avgLQI);
				print(avgDist + "\t" + avgLQI + "\t" + confLQI, outFlogger);
			}
		}
	}
	
	private double calcAvgDist(Vector<TelosBSignalStrengthResult> currBucket) {
		double total = 0;
		Enumeration<TelosBSignalStrengthResult> e = currBucket.elements();
		while (e.hasMoreElements()) {
			total += e.nextElement().getDist();
		}
		return total / currBucket.size();
	}
	
	private double calcAvgRSSI(Vector<TelosBSignalStrengthResult> currBucket) {
		double total = 0;
		Enumeration<TelosBSignalStrengthResult> e = currBucket.elements();
		while (e.hasMoreElements()) {
			total += e.nextElement().getRxRecord().getRSSI();
		}
		return total / currBucket.size();
	}
	
	private double calcAvgLQI(Vector<TelosBSignalStrengthResult> currBucket) {
		double total = 0;
		Enumeration<TelosBSignalStrengthResult> e = currBucket.elements();
		while (e.hasMoreElements()) {
			total += e.nextElement().getRxRecord().getLQI();
		}
		return total / currBucket.size();
	}
	
	private double calcConfRSSI(Vector<TelosBSignalStrengthResult> currBucket, double avgRSSI) {
		if (currBucket.size() == 0)
			return 0;
		
		// Estimate the population standard deviation
		double stddev = 0;
		Enumeration<TelosBSignalStrengthResult> e = currBucket.elements();
		while (e.hasMoreElements()) {
			stddev += Math.pow(e.nextElement().getRxRecord().getRSSI() - avgRSSI, 2);
		}
		stddev = Math.sqrt(stddev / currBucket.size());
		
		// Calculate the standard error of the mean
		double stdErrMean = stddev / Math.sqrt(currBucket.size());
		
		return Z_VALUE * stdErrMean;
	}
	
	private double calcConfLQI(Vector<TelosBSignalStrengthResult> currBucket, double avgLQI) {
		if (currBucket.size() == 0)
			return 0;
		
		// Estimate the population standard deviation
		double stddev = 0;
		Enumeration<TelosBSignalStrengthResult> e = currBucket.elements();
		while (e.hasMoreElements()) {
			stddev += Math.pow(e.nextElement().getRxRecord().getLQI() - avgLQI, 2);
		}
		stddev = Math.sqrt(stddev / currBucket.size());
		
		// Calculate the standard error of the mean
		double stdErrMean = stddev / Math.sqrt(currBucket.size());
		
		return Z_VALUE * stdErrMean;
	}
	
	/**
	 * Prints the state of the buckets.
	 * 
	 * @param buckets The buckets.
	 * @param flogger The file logger to which to print the buckets.
	 */
	private void printBuckets(Hashtable<Integer, Vector<TelosBSignalStrengthResult>> buckets, FileLogger flogger) {
		print("State of buckets:", flogger);
		
		// First put all of the keys in an ArrayList so they can be sorted.
		ArrayList<Integer> keyList = new ArrayList<Integer>();
		Enumeration<Integer> keys = buckets.keys();
		while (keys.hasMoreElements()) {
			keyList.add(keys.nextElement());
		}
		
		// Sort the keys
		Collections.sort(keyList);
		
		// Print the state of the buckets
		for (int i=0; i < keyList.size(); i++) {
			int currKey = keyList.get(i);
			Vector<TelosBSignalStrengthResult> currBucket = buckets.get(currKey);
			int lowerdist = currKey;
			int upperDist = currKey + AVERAGE_WINDOW_SIZE;
			print("Bucket: [" + lowerdist + ", " + upperDist + "): " + currBucket.size() + " elements:", flogger);

			if (currBucket.size() > 0) {
				print(currBucket.get(0).getTableHeader(), flogger);
				Enumeration<TelosBSignalStrengthResult> e = currBucket.elements();
				while (e.hasMoreElements()) {
					TelosBSignalStrengthResult currElement = e.nextElement();
					print(currElement.toString(), flogger);
				}
			}
		}
	}
	
	/**
	 * Determines which bucket the result should be stored in and
	 * adds it to the bucket.  The buckets are indexed by distance.
	 * 
	 * @param r The result.
	 * @param buckets The buckets.
	 */
	private void insertIntoBucket(TelosBSignalStrengthResult r, Hashtable<Integer, Vector<TelosBSignalStrengthResult>> buckets) {
		int key = ((int)(r.getDist() / AVERAGE_WINDOW_SIZE)) * AVERAGE_WINDOW_SIZE;
		Vector<TelosBSignalStrengthResult> bucket = buckets.get(key);
		if (bucket != null)
			bucket.add(r);
		else {
			logErr("Could not find bucket for result " + r);
			System.exit(1);
		}
	}
	
	/**
	 * Finds the maximum distance in the specified vector of data.
	 * 
	 * @param data The data.
	 * @return The maximum distance within the data.
	 */
	private double findMaxDist(Vector<TelosBSignalStrengthResult> data) {
		double result = 0;
		Enumeration<TelosBSignalStrengthResult> e = data.elements();
		while (e.hasMoreElements()) {
			TelosBSignalStrengthResult res = e.nextElement();
			if (result < res.getDist())
				result = res.getDist();
		}
		return result;
	}
	
	private void logErr(String msg) {
		String result = "SSvDAvgGenerator: " + msg;
		if (System.getProperty ("PharosMiddleware.debug") != null) 
			System.err.println(result);
		if (flogger != null)
			flogger.log(result);
	}
	
	private void log(String msg) {
		TelosBSSvDAvgGenerator.log(msg, this.flogger);
	}
	
	private static void log(String msg, FileLogger flogger) {
		String result = "SSvDAvgGenerator: " + msg;
		if (System.getProperty ("PharosMiddleware.debug") != null) 
			System.out.println(result);
		if (flogger != null)
			flogger.log(result);
	}
	
	private void print(String msg, FileLogger flogger) {
		System.out.println(msg);
		if (flogger != null)
			flogger.log(msg);
	}
	
	private static void print(String msg) {
		if (System.getProperty ("PharosMiddleware.debug") != null)
			System.out.println(msg);
	}
	
	private static void usage() {
		System.setProperty ("PharosMiddleware.debug", "true");
		print("Usage: pharoslabut.logger.analyzer.ssvd.TelosBSSvDAvgGenerator <options>\n");
		print("Where <options> include:");
		print("\t-input <input file>: The directory containing experiment data (required)");
		print("\t-output <output file>: The file in which the results are saved (required).");
		print("\t-log <log file name>: The file in which to log debug statements (default null)");
		print("\t-debug: enable debug mode");
	}
	
	public static void main(String[] args) {
		String inputFile = null;
		String outputFile = null;
		FileLogger flogger = null; // for saving debug output
		
		// Process the command line arguments...
		try {
			for (int i=0; i < args.length; i++) {
		
				if (args[i].equals("-log"))
					flogger = new FileLogger(args[++i], false);
				else if (args[i].equals("-input"))
					inputFile = args[++i];
				else if (args[i].equals("-debug") || args[i].equals("-d"))
					System.setProperty ("PharosMiddleware.debug", "true");
				else if (args[i].equals("-output"))
					outputFile = args[++i];
				else {
					usage();
					System.exit(1);
				}
			}
		} catch(Exception e) {
			e.printStackTrace();
			usage();
			System.exit(1);
		}
		
		if (inputFile == null || outputFile == null) {
			usage();
			System.exit(1);
		}
		
		
		TelosBSSvDAvgGenerator averager = new TelosBSSvDAvgGenerator(flogger);
		averager.generateAverage(inputFile, outputFile);
	}
}
