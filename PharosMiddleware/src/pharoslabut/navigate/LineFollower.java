package pharoslabut.navigate;

import playerclient3.*;
import playerclient3.structures.blobfinder.*;
import playerclient3.structures.ptz.PlayerPtzCmd;
import playerclient3.structures.*;
import pharoslabut.logger.*;
import pharoslabut.navigate.LineFollowerEvent.LineFollowerEventType;

import java.util.*;

/**
 * Follows a line using a CMUcam2.  It uses BlobfinderInterface
 * and PtzInterface to follow the line.
 * 
 * @author Sushen Patel
 * @author Seth Gee
 * @author Chien-Liang Fok
 */
public class LineFollower implements Runnable {
	
	/**
	 * This is the cycle period of the LineFollower thread.
	 * It is in milliseconds.
	 */
	public static int CYCLE_PERIOD = 100; // 10Hz
	
	/**
	 * This is the maximum valid age of the blob data.  Anything older than that is discarded.
	 */
	public static final long BLOB_MAX_VALID_AGE = 1500;	//modified by sushen
	
	/**
	 * The maximum speed of the robot in meters per second.
	 */
	public static final double MAX_SPEED = 0.6;		//modified by sushen
	
	/**
	 * The minimum speed of the robot in meters per second.
	 */
	public static final double MIN_SPEED = 0.37;		//modified by sushen 
	
	/**
	 * The maximum turn angle of the robot in degrees.
	 */
	public static final double MAX_TURN_ANGLE = 30;
	public int turnSign;
	

	/**-------------------------------------------------------------------------------added by sushen--------
	* The maximum pan angle of the camera (neither in degrees nor radians)
	*/
	public static final double PAN_STEP = 7;
	public static final double MAX_PAN = 40;
	//public static final double PAN_OFFSET = 0;		//implemented in robot driver through configuration file because 
	//public static final double TILT_OFFSET = 50;		//each robot might need different offsets, see wiki on how to change config file and drivers.
	//private boolean panFlag = false;
	public int oldSign = 0;
	public int noBlobs = 0;
	// ------------------------------------------------------------------------------------------------------
	
	private Vector<LineFollowerEventListener> listeners = new Vector<LineFollowerEventListener>();
	
	private PlayerClient client = null;	
	private BlobfinderInterface bfi = null;
	private PtzInterface ptz = null;
	
	private boolean done = false;
	
	/**
	 * Keeps track of whether an event for the secondary blob was already generated.
	 * Prevents many secondary blob events from being generated by a single secondary
	 * blob.
	 */
	private LineFollowerEventType previousEventType = null;
	
	private Position2DInterface p2di = null;
	
	double angle = 0;
	double speed = 0;
	double pan = 0;  // ----------------------------------------------------------------added by sushen--------
	double panOld = 0;
	
	/**
	 * A reference to the thread performing the line following task.  It is null initially, but
	 * is assigned a value when start() is called.
	 */
	private Thread thread = null;
	
	/**
	 * The constructor.
	 * 
	 * @param serverIP The IP address of the server.
	 * @param serverPort The port of the server.
	 */
	public LineFollower(String serverIP, int serverPort) {
		// connect to player server
		try{
			client = new PlayerClient(serverIP, serverPort);
		} catch (PlayerException e) { Logger.logErr("Could not connect to server."); System.exit(1); }
		Logger.log("Created robot client.");
		
		// connect to blobfinder
		try{
			bfi = client.requestInterfaceBlobfinder(0, PlayerConstants.PLAYER_OPEN_MODE);
		} catch (PlayerException e) { Logger.logErr("Could not connect to blob finder proxy."); System.exit(1);}
		Logger.log("Created BlobFinder.");
		
		//set up pos. 2d proxy
		try{
			p2di = client.requestInterfacePosition2D(0, PlayerConstants.PLAYER_OPEN_MODE);
		} catch (PlayerException e) { Logger.logErr("Could not connect to position 2d proxy."); System.exit(1);}
		Logger.log("Created Position2dProxy.");
		
		p2di.setSpeed(0f,0f);  // ensure robot is initially stopped

		// Connect to PTZ
		try {
			ptz = client.requestInterfacePtz(0, PlayerConstants.PLAYER_OPEN_MODE);
		} catch (PlayerException e) { Logger.logErr("Could not connect to PTZ proxy."); System.exit(1);}
		Logger.log("Connected to PTZ proxy.");

		Logger.log("Changing Player server mode to PUSH...");
		client.requestDataDeliveryMode(playerclient3.structures.PlayerConstants.PLAYER_DATAMODE_PUSH);
		
		Logger.log("Setting Player Client to run in continuous threaded mode...");
		client.runThreaded(-1, -1);	
	}
	
	/**
	 * @return The player client.
	 */
	public PlayerClient getPlayerClient() {
		return client;
	}
	
	/**
	 * Adds a LineFollowerEventListener to this object.
	 * 
	 * @param lfel the LineFollowerEventListener to add.
	 */
	public void addListener(LineFollowerEventListener lfel) {
		listeners.add(lfel);
	}
	
	/**
	 * Removes a LineFollowerEventListener from this object.
	 * 
	 * @param lfel the LineFollowerEventListener to remove.
	 */
	public void removeListener(LineFollowerEventListener lfel) {
		listeners.remove(lfel);
	}
	
	/**
	 * Broadcasts the LineFollowerEvent a to all registered listeners.
	 * 
	 * @param lfe The event to broadcast.
	 */
	private void notifyListeners(final LineFollowerEvent lfe) {
		Enumeration<LineFollowerEventListener> e = listeners.elements();
		while(e.hasMoreElements()) {
			final LineFollowerEventListener lfel = e.nextElement();
			new Thread(new Runnable() {
				public void run () {
					lfel.newLineFollowerEvent(lfe, LineFollower.this);
				}
			}).start();
		}
	}
	
	/**
	 * Starts the line following process.
	 */
	public synchronized void start() {
		if (thread == null) {
			done = false;
			thread = new Thread(this);
			thread.start();
			Logger.log("Thread started");
		} else
			Logger.log("WARNING: Thread already started.");
	}
	
	/**
	 * Stops the line following process.
	 */
	public synchronized void stop() {
		if (thread != null) {
			Logger.log("setting done = true");
			done = true;
			
			Logger.log("Joining thread...");
			try {
				thread.join();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			Logger.log("Thread joined...");
			thread = null; // was causing RemoteIntersectionManager to crash 
			Logger.log("thread stopped.");
		} else
			Logger.log("WARNING: already stopped.");
	}
	
	/**
	 * The maximum turn angle should be throttled based on the 
	 * divergence of the blob from the center.  A large divergence indicates the
	 * need for a large turn angle and vice-versa.
	 * Since the robot is programmed to move faster when the
	 * divergence is lower, this effectively dampens the robot's 
	 * turn rate when it is moving faster, thus achieving greater
	 * stability.  Without this, the robot would have a tendency to 
	 * swerve side-to-side as it increases in speed. 
	 * 
	 * @param divergencePct The percent divergence.
	 * @return The maximum turn angle.
	 */
	private double getMaxTurnAngle(double divergencePct) {
		Logger.log("getMaxTurnAgle: " + divergencePct);
		if (divergencePct < .05)
			return MAX_TURN_ANGLE * 0.05;
		if (divergencePct < .10)
			return MAX_TURN_ANGLE * 0.10;
		if (divergencePct < .15)
			return MAX_TURN_ANGLE * 0.15;
		if (divergencePct < .20)
			return MAX_TURN_ANGLE * 0.20;
		if (divergencePct < .25)
			return MAX_TURN_ANGLE * 0.25;
		if (divergencePct < .30)
			return MAX_TURN_ANGLE * 0.30;
		if (divergencePct < .35)
			return MAX_TURN_ANGLE * 0.35;
		if (divergencePct < .40)
			return MAX_TURN_ANGLE * 0.40;
		if (divergencePct < .45)
			return MAX_TURN_ANGLE * 0.45;
		if (divergencePct < .50)
			return MAX_TURN_ANGLE * 0.50;
		if (divergencePct < .55)
			return MAX_TURN_ANGLE * 0.55;
		if (divergencePct < .60)
			return MAX_TURN_ANGLE * 0.60;
		if (divergencePct < .65)
			return MAX_TURN_ANGLE * 0.65;
		if (divergencePct < .70)
			return MAX_TURN_ANGLE * 0.70;
		if (divergencePct < .75)
			return MAX_TURN_ANGLE * 0.75;
		if (divergencePct < .80)
			return MAX_TURN_ANGLE * 0.80;
		if (divergencePct < .85)
			return MAX_TURN_ANGLE * 0.85;
		if (divergencePct < .90)
			return MAX_TURN_ANGLE * 0.90;
		if (divergencePct < .95)
			return MAX_TURN_ANGLE * 0.95;
/*		if (divergencePct < .40)
			return MAX_TURN_ANGLE * 0.45;	//modified by sushen
		if (divergencePct < .50)
			return MAX_TURN_ANGLE * 0.6;	//modified by sushen
		if (divergencePct < .60)
			return MAX_TURN_ANGLE * 0.75;	//modified by sushen
		if (divergencePct < .70)
			return MAX_TURN_ANGLE * 0.9;	//modified by sushen
*/		return MAX_TURN_ANGLE;
	}
	
	/**
	 * Adjusts the heading and speed of the robot based on the position of the blob.
	 * 
	 * @param blob The blob to use to calculate the heading of the robot.
	 * @param midPoint The middle of the field of view.
	 */
	private void adjustHeadingAndSpeed(PlayerBlobfinderBlob blob, int midPoint) {
		Logger.log("Blob area=" + blob.getArea() + ", color=" + blob.getColor() + ", left=" + blob.getLeft() + ", right=" + blob.getRight() + ", x=" + blob.getX());

		//int turnSign;		//-------------------------------------------------------------------------------added by sushen----------
		if (blob.getX() > midPoint) {
			Logger.log("Center of blob is right of midpoint, must turn right!");
			turnSign = -1;
		} else {
			Logger.log("Center of blob is left of midpoint, must turn left!");
			turnSign = 1;
		}

		// Make the angle adjustment proportional to the degree to which the heading has diverged
		// from being perfectly centered on the line.
		// A divergencePct of 1 means the robot is the most off in terms of following the line.
		// A divergencePct of 0 means that the robot is perfectly centered on the line.
		double divergence = Math.abs(blob.getX() - midPoint);  // blob.getX() returns the centroid's X coordinate
		double divergencePct = divergence / midPoint;
		Logger.log("divergencePct = " + divergencePct);
			
		/*//-----------------------------------------------------added by sushen---------------------------------
		if(divergencePct > 0.7 && panFlag == false){ 
			pan = turnSign * PAN_STEP * divergencePct;
			panFlag = true;
			oldSign = turnSign;
		}
		else if(panFlag == true){
			pan = Math.abs(pan) - 1;
			pan *= oldSign;
		}*/

		//-----------------------------------------alternative method than above----------------------------------
//		if(divergencePct < 0.6)
//			pan = 0;
//		else {pan = turnSign * PAN_STEP * divergencePct;}
		pan = panOld + ( turnSign * divergencePct * PAN_STEP );
		if ( pan > MAX_PAN ) {
			pan = MAX_PAN;
		}
		if( pan < (MAX_PAN * -1) ) {
			pan = MAX_PAN * -1;
		}
		Logger.log("panOld=" + panOld + " pan=" + pan + " divergencePct=" + divergencePct);
		panOld = pan;
		
		//--------------------------------------------------------------------------------------------------------
		
//		angle = turnSign * getMaxTurnAngle(divergencePct) * divergencePct;
		angle = MAX_TURN_ANGLE * ( (pan/MAX_PAN) + (turnSign*divergencePct) );
//		angle = MAX_TURN_ANGLE * pan / MAX_PAN;
		Logger.log(":::: pan share=" + pan/MAX_PAN*MAX_TURN_ANGLE + " div share=" + MAX_TURN_ANGLE*turnSign*divergencePct );
		if ( angle > MAX_TURN_ANGLE ) {
			Logger.log("BUG: angle > MAX_TURN_ANGLE. angle=" + angle );
			angle = MAX_TURN_ANGLE;
		}
		if ( angle < (MAX_TURN_ANGLE * -1) ) {
			Logger.log("BUG: angle > MAX_TURN_ANGLE. angle=" + angle );
			angle = MAX_TURN_ANGLE * -1;
		}
		/*/ Make the speed proportional to the degree to which the heading is off. 
		speed = MAX_SPEED * (1 - divergencePct);
		if (speed < MIN_SPEED)
			speed = MIN_SPEED;
		*/
		//---------------------------------------------------------------------------Alternate method added by sushen -------------
		speed = MIN_SPEED + ( (MAX_SPEED - MIN_SPEED) * (1 - Math.abs(angle/MAX_TURN_ANGLE)) );
//speed = 0.65;
//		speed = ((MAX_SPEED - MIN_SPEED) * (1 - divergencePct)) + MIN_SPEED;
//		if(angle > (0.6*MAX_TURN_ANGLE) )
//			speed = MIN_SPEED;
//			angle = turnSign * MAX_TURN_ANGLE;
	}
	
	/**
	 * The secondary blob is used for indicating three things: 
	 * 
	 * APPROACHING_INTERSECTION: secondary blob right of line
	 * ENTERING_INTERSECTION: secondary blob left of line
	 * EXITING_INTERSECTION: secondary blob crossing line
	 * 
	 * @param blob
	 */
	private void handleSecondaryBlob(PlayerBlobfinderBlob primary, PlayerBlobfinderBlob secondary) {
		// TODO: Add logic that determines the type of event that was detected.
		// One the type of event is determined, broadcast it to all registered listeners
		// Here's an example of how to broadcast an APPROACHING event.
		Logger.log("area=" + secondary.getArea() + ", primary x=" + primary.getX() + ", secondary x=" + secondary.getX() 
				+ ", blob width=" + (Math.abs(secondary.getLeft()-secondary.getRight())) + ", previousEventType= " + previousEventType);
		
		if ((primary.getX() < secondary.getX()) && (Math.abs(secondary.getLeft() - secondary.getRight()) < 80)) {
			if (previousEventType == null || previousEventType  != LineFollowerEvent.LineFollowerEventType.APPROACHING) {
				Logger.log("APPROACHING Intersection!");
				previousEventType = LineFollowerEvent.LineFollowerEventType.APPROACHING;
				LineFollowerEvent lfe = new LineFollowerEvent(LineFollowerEvent.LineFollowerEventType.APPROACHING);
				notifyListeners(lfe);
			} else
				Logger.log("Supressing duplicate APPROACHING event");
		}
		else if ((primary.getX() > secondary.getX()) && (Math.abs(secondary.getLeft() - secondary.getRight()) < 80)) { 
			if (previousEventType == null || previousEventType  != LineFollowerEvent.LineFollowerEventType.ENTERING) {
				Logger.log("ENTERING Intersection!");
				previousEventType = LineFollowerEvent.LineFollowerEventType.ENTERING;
				LineFollowerEvent lfe = new LineFollowerEvent(LineFollowerEvent.LineFollowerEventType.ENTERING);
				notifyListeners(lfe);
			} else
				Logger.log("Supressing duplicate ENTERING Intersection event");
		}
		else if ((Math.abs(secondary.getLeft() - secondary.getRight()) > 100)) {
			if (previousEventType == null || previousEventType  != LineFollowerEvent.LineFollowerEventType.EXITING) {
				Logger.log("EXITING Intersection!");
				previousEventType = LineFollowerEvent.LineFollowerEventType.EXITING;
				LineFollowerEvent lfe = new LineFollowerEvent(LineFollowerEvent.LineFollowerEventType.EXITING);
				notifyListeners(lfe);
			} else
				Logger.log("Supressing duplicate EXITING Intersection event");
		}
	}

	/**
	 * Processes the blobs being reported by the CMUCam2.  There are two blobs.  The first one
	 * is a black blob that guides the robot so it stays on the lane.  The second blob is
	 * a blue one that indicates when the robot is approaching, entering and exiting the intersection.
	 * 
	 * @param data The blob finder data that contains information about all of the blobs in the
	 * current field of view.
	 */
	private void processBlobs(PlayerBlobfinderData data) {
		// Check to make sure we have valid data...
		if (data != null) {
			int numBlobs = data.getBlobs_count();
			Logger.log("There are " + numBlobs + " blobs...");

			if(numBlobs > 0) {	
				PlayerBlobfinderBlob[] blobListCopy = null;
				
				// Create a copy of the blobList array to avoid conflicts with the array reference
				// being changed while it is being read from.
				synchronized(data) {
					PlayerBlobfinderBlob[] blobList = data.getBlobs();
					blobListCopy = new PlayerBlobfinderBlob[blobList.length];
					System.arraycopy(blobList, 0, blobListCopy, 0, blobList.length);
				}

				// All of the following checks should not be necessary.  They were added
				// to counter a null pointer exception being occasionally thrown.
				if(blobListCopy != null && blobListCopy.length > 0 && blobListCopy[0] != null) {
					noBlobs = 0; //-------------------------------------------------------------------------------added by sushen ------
					int midPoint = data.getWidth()/2;
					if( (blobListCopy[0].getArea() < 200) ) {
						Logger.log("BLOB HEIGHT " + blobListCopy[0].getArea());
						adjustHeadingAndSpeed(blobListCopy[0], midPoint);
					} else {
						return;
					}
				} else {
					Logger.logErr("No primary blob, stopping robot...");
					speed = angle = 0;					
				}

				// Right now only designed for detection of blue secondary blob
				try {
					if(blobListCopy != null && numBlobs > 1 && blobListCopy[1] != null) {
						handleSecondaryBlob(blobListCopy[0], blobListCopy[1]);
					} 
					else {
						Logger.log("No secondary blob!");
						previousEventType = null;
					}
				} catch(ArrayIndexOutOfBoundsException e) {
					// TODO Figure out why this sometimes happens.
					Logger.logErr("got an unexpected ArrayIndexOutOfBoundsException: " + e.getMessage());
					previousEventType = null;
				}
			}
			else {
				Logger.logErr("No blobs present, stopping robot...");
				speed = angle = 0;
				noBlobs += 1;                                //----------------------------------------------------this line too added by sushen
				if(noBlobs > 7){				// if after 7 passes or .7 second there is no blob
					pan = 20 * turnSign;						//--------------------------added by sushen
					Logger.log("Pan value after no blobs detected= " + pan + "\nturnSign = " + turnSign +"\n\n\n\n\n");///// added by sushen 
				}			
			}
		} else {
			Logger.logErr("Blob data is null, stopping robot...");
			speed = angle = 0;
			Logger.log("Something is happening 1!!!\n\n\n\n");
		}
	}
	
	/**
	 * This contains the main loop of the LineFollower thread.
	 */
	public void run() {
		long dataTimeStamp = 0;
		// -------------------------------------------------------------added by sushen------------------------------------------------------------
			PlayerPtzCmd ptzCmd = new PlayerPtzCmd();
			ptzCmd.setPan((float) 0);		//change 0 to PAN_OFFSET if not being implemented in driver and initialize variable at top
			ptzCmd.setTilt((float) 0);		//change 0 to TILT_OFFSET if not being implemented in driver and initialize variable at top
			ptz.setPTZ(ptzCmd);
			pause(50);	
		//-----------------------------------------------------------------------------------------------------------------------------------------
		
		while(!done) {
			
			
			// If new blob data is available, get it and process it.
			if (bfi.isDataReady()) {
				dataTimeStamp = System.currentTimeMillis();
				processBlobs(bfi.getData());
			}
			
			
			// If no blob data is received within a certain time window, stop the robot.
			if (System.currentTimeMillis() - dataTimeStamp > BLOB_MAX_VALID_AGE) {
				Logger.log("ERROR: No blob data within valid window of " + BLOB_MAX_VALID_AGE + "ms");
				speed = angle = 0;
			}
			
			p2di.setSpeed(speed, dtor(angle));

			//--------------------------------------------------------------------------added by sushen-----------------------------
			/* commented out because alternative method is being used in adjustHeadingAndSpeed
			if(panFlag && ((oldSign == -1 && pan >= 0) || (oldSign == 1 && pan <= 0))){	//check if pan value has gone past the zero point, if so set to 0
				pan = 0;
				panFlag = false;
			}*/

			ptzCmd.setPan((float) (pan));			//move camera, change to pan + PAN_OFFSET if not implemented in driver
			ptz.setPTZ(ptzCmd);
			// ----------------------------------------------------------------------------------------------------------------------


			Logger.log("Sending Command, speed=" + speed + ", angle=" + angle + ", pan=" +pan);
			pause(CYCLE_PERIOD);

		}
		
		Logger.log("thread exiting, ensuring robot is stopped...");
		speed = angle = 0;
		p2di.setSpeed(speed, dtor(angle));
		
	}
	
	/**
	 * Converts degrees to radians.
	 * 
	 * @param degrees The angle in degrees.
	 * @return The angle in radians.
	 */
	private double dtor(double degrees) {
		double radians = degrees * (Math.PI / 180);
		return radians;
	}

	private void pause(int duration) {
		synchronized(this) {
			try {
				wait(duration);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
