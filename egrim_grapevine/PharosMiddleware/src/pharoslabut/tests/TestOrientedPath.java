package pharoslabut.tests;

import java.util.Vector;

import pharoslabut.logger.FileLogger;
import pharoslabut.logger.analyzer.*;
import pharoslabut.navigate.Location;

/**
 * Generates a GPSVisualizer script that plots the ideal path and oriented ideal path
 * that a robot should follow.
 * 
 * @author Chien-Liang Fok
 */
public class TestOrientedPath {
	
	private static void usage() {
		System.err.println("Usage: " + TestOrientedPath.class.getName() + " <options>\n");
		System.err.println("Where <options> include:");
		System.err.println("\t-log <robot exp log file>: The log file generated by the robot during an experiment. (required)");
		System.err.println("\t-d: Enable debug mode (default false)");
	}
	
	private static void print(String msg) {
		System.out.println(TestOrientedPath.class.getName() + ": " + msg);
	}
	
	public static void main(String[] args) {
		String logFileName = null;
		
		try {
			for (int i=0; i < args.length; i++) {
				if (args[i].equals("-log") || args[i].equals("-l")) {
					logFileName = args[++i];
				}
				else if (args[i].equals("-debug") || args[i].equals("-d")) {
					System.setProperty ("PharosMiddleware.debug", "true");
				} else if (args[i].equals("-help") || args[i].equals("-h")) {
					usage();
					System.exit(0);
				} else {
					System.err.println("Unknown option: " + args[i]);
					usage();
					System.exit(1);
				}
			}
		} catch(Exception e) {
			e.printStackTrace();
			System.exit(1);
		}
		
		// Determine the output file name.  This is the input log file name but ending
		// with "-TestOrientedPath.csv"
		String outputFileName = null;
		if (logFileName.contains("."))
			outputFileName = logFileName.substring(0, logFileName.lastIndexOf('.'));
		else
			outputFileName = logFileName;
		outputFileName += "-TestOrientedPath.csv";
		print("OutputFileName is: " + outputFileName);
		
		print("Reading the robot experiment data...");
		RobotExpData robotData = new RobotExpData(logFileName);
		
		FileLogger flogger = new FileLogger(outputFileName, false);
		Vector<PathEdge> pathEdges = robotData.getPathEdges();
		
		print("Adding the theoretical ideal path...");
		flogger.log("type,latitude,longitude,name,color");
		for (int i=0; i < pathEdges.size(); i++) {
			PathEdge currEdge = pathEdges.get(i);
			
			Location startLoc = currEdge.getIdealStartLoc();
			long startTime = currEdge.getStartTime();
			
			Location stopLoc = currEdge.getEndLocation();
			long endTime = currEdge.getEndTime();
			
			// Create two lines, one for interpolating latitudes, the other for interpolating longitudes.
			Line latLine = new Line(new Location(startLoc.latitude(), startTime), new Location(stopLoc.latitude(), endTime));
			Line lonLine = new Line(new Location(startLoc.longitude(), startTime), new Location(stopLoc.longitude(), endTime));
			
			for (long currTime = startTime; currTime < endTime; currTime += 100) {
				String line = "T," + latLine.getLatitude(currTime) + "," + lonLine.getLatitude(currTime);
				if (i == 0 && currTime == startTime)
					line += ", ideal path, blue";
				flogger.log(line);
			}
		}
		
		print("Adding the ideal path from where the robot started...");
		flogger.log("type,latitude,longitude,name,color");
		for (int i=0; i < pathEdges.size(); i++) {
			PathEdge currEdge = pathEdges.get(i);
			
			Location startLoc = currEdge.getStartLoc();
			long startTime = currEdge.getStartTime();
			
			Location stopLoc = currEdge.getEndLocation();
			long endTime = currEdge.getEndTime();
			
			// Create two lines, one for interpolating latitudes, the other for interpolating longitudes.
			Line latLine = new Line(new Location(startLoc.latitude(), startTime), new Location(stopLoc.latitude(), endTime));
			Line lonLine = new Line(new Location(startLoc.longitude(), startTime), new Location(stopLoc.longitude(), endTime));
			
			for (long currTime = startTime; currTime < endTime; currTime += 100) {
				String line = "T," + latLine.getLatitude(currTime) + "," + lonLine.getLatitude(currTime);
				if (i == 0 && currTime == startTime)
					line += ", actual start ideal path, red";
				flogger.log(line);
			}
		}
		
		Vector<Location> orientedStartLineStarts = new Vector<Location>();
		
		print("Adding oriented start ideal path...");
		flogger.log("type,latitude,longitude,name,color");
		for (int i=0; i < pathEdges.size(); i++) {
			PathEdge currEdge = pathEdges.get(i);
			
			LocationState orientedLoc = robotData.getOrientedLocation(currEdge, 0.25);
			
			Location startLoc = orientedLoc.getLoc();
			long startTime = orientedLoc.getTimestamp();
			orientedStartLineStarts.add(startLoc);
			
			Location stopLoc = currEdge.getEndLocation();
			long endTime = currEdge.getEndTime();
			
			// Create two lines, one for interpolating latitudes, the other for interpolating longitudes.
			Line latLine = new Line(new Location(startLoc.latitude(), startTime), new Location(stopLoc.latitude(), endTime));
			Line lonLine = new Line(new Location(startLoc.longitude(), startTime), new Location(stopLoc.longitude(), endTime));
			
			for (long currTime = startTime; currTime < endTime; currTime += 100) {
				String line = "T," + latLine.getLatitude(currTime) + "," + lonLine.getLatitude(currTime);
				if (i == 0 && currTime == startTime)
					line += ", oriented start ideal path, green";
				flogger.log(line);
			}
		}		
		
		// Include the actual way points
		print("Adding the actual way points...");
		flogger.log("type,latitude,longitude,color");
		Vector<Location> waypoints = robotData.getWayPoints();
		for (int i=0; i < waypoints.size(); i++) {
			Location currLoc = waypoints.get(i);
			String line = "W," + currLoc.latitude() + "," + currLoc.longitude() + ", Actual Waypoint, green";
			flogger.log(line);
		}
		
		// Include the oriented start line's start location
		print("Adding oriented start line's start location...");
		flogger.log("type,latitude,longitude,color");
		for (int i=0; i < orientedStartLineStarts.size(); i++) {
			Location currLoc = orientedStartLineStarts.get(i);
			String line = "W," + currLoc.latitude() + "," + currLoc.longitude() + ", Oriented start start, orange";
			flogger.log(line);
		}
		
		// Include the actual path traveled by the robot
		print("Adding the actual path traveled by the robot...");
		flogger.log("type,latitude,longitude,name,color");
		for (long time = robotData.getStartTime(); time < robotData.getStopTime(); time += 1000) {
			Location currLoc = robotData.getLocation(time);
			String line = "T," + currLoc.latitude() + "," + currLoc.longitude();
			if (time == robotData.getStartTime())
				line += ", actual robot path, purple";
			flogger.log(line);
		}
		print("Evaluation script saved to " + outputFileName + ", upload it to GPSVisualizer to visualize...");
	}
}
