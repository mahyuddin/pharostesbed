package pharoslabut.navigate;

import playerclient3.*;
import playerclient3.structures.blobfinder.*;
import playerclient3.structures.*;
import pharoslabut.logger.*;
import pharoslabut.navigate.LineFollowerEvent.LineFollowerEventType;

import java.util.*;

/**
 * Follows a line using a CMUcam2.
 * 
 * @author Seth Gee
 * @author Chien-Liang Fok
 */
public class LineFollower implements Runnable {
	
	/**
	 * This is the cycle period of the LineFollower thread.
	 * It is in milliseconds.
	 */
	public static int CYCLE_PERIOD = 100; // 10Hz
	
	/**
	 * This is the maximum valid age of the blob data.  Anything older than that is discarded.
	 */
	public static final long BLOB_MAX_VALID_AGE = 1000;
	
	/**
	 * The maximum speed of the robot in meters per second.
	 */
	public static final double MAX_SPEED = .5;
	
	/**
	 * The minimum speed of the robot in meters per second.
	 */
	public static final double MIN_SPEED = 0.35;
	
	/**
	 * The maximum turn angle of the robot in degrees.
	 */
	public static final double MAX_TURN_ANGLE = 40;
	
	private Vector<LineFollowerEventListener> listeners = new Vector<LineFollowerEventListener>();
	
	private PlayerClient client = null;	
	private BlobfinderInterface bfi = null;
	
	private boolean done = false;
	
	/**
	 * Keeps track of whether an event for the secondary blob was already generated.
	 * Prevents many secondary blob events from being generated by a single secondary
	 * blob.
	 */
	private LineFollowerEventType previousEventType = null;
	
	private Position2DInterface p2di = null;
	
	double angle = 0;
	double speed = 0;
	
	private FileLogger flogger = null;
	
	/**
	 * A reference to the thread performing the line following task.  It is null initially, but
	 * is assigned a value when start() is called.
	 */
	private Thread thread = null;
	
	/**
	 * The constructor.
	 * 
	 * @param serverIP The IP address of the server.
	 * @param serverPort The port of the server.
	 * @param flogger The file logger for recording debug data.
	 */
	public LineFollower(String serverIP, int serverPort, FileLogger flogger) {
		this.flogger = flogger;
		
		// connect to player server
		try{
			client = new PlayerClient(serverIP, serverPort);
		} catch (PlayerException e) { log("Error, could not connect to server.", false); System.exit(1); }
		log("Created robot client.");
		
		// connect to blobfinder
		try{
			bfi = client.requestInterfaceBlobfinder(0, PlayerConstants.PLAYER_OPEN_MODE);
		} catch (PlayerException e) { log("Error, could not connect to blob finder proxy.", false); System.exit(1);}
		log("Created BlobFinder.");
		
		//set up pos. 2d proxy
		try{
			p2di = client.requestInterfacePosition2D(0, PlayerConstants.PLAYER_OPEN_MODE);
		} catch (PlayerException e) { log("Error, could not connect to position 2d proxy.", false); System.exit(1);}
		log("Created Position2dProxy.");
		
		p2di.setSpeed(0f,0f);  // ensure robot is initially stopped
	}
	
	/**
	 * @return The player client.
	 */
	public PlayerClient getPlayerClient() {
		return client;
	}
	
	/**
	 * Adds a LineFollowerEventListener to this object.
	 * 
	 * @param lfel the LineFollowerEventListener to add.
	 */
	public void addListener(LineFollowerEventListener lfel) {
		listeners.add(lfel);
	}
	
	/**
	 * Removes a LineFollowerEventListener from this object.
	 * 
	 * @param lfel the LineFollowerEventListener to remove.
	 */
	public void removeListener(LineFollowerEventListener lfel) {
		listeners.remove(lfel);
	}
	
	/**
	 * Broadcasts the LineFollowerEvent a to all registered listeners.
	 * 
	 * @param lfe The event to broadcast.
	 */
	private void notifyListeners(final LineFollowerEvent lfe) {
		Enumeration<LineFollowerEventListener> e = listeners.elements();
		while(e.hasMoreElements()) {
			final LineFollowerEventListener lfel = e.nextElement();
			new Thread(new Runnable() {
				public void run () {
					lfel.newLineFollowerEvent(lfe, LineFollower.this);
				}
			}).start();
		}
	}
	
	/**
	 * Starts the line following process.
	 */
	public synchronized void start() {
		if (thread == null) {
			done = false;
			thread = new Thread(this);
			thread.start();
			log("start: thread started");
		} else
			log("start: WARNING: Thread already started.");
	}
	
	/**
	 * Stops the line following process.
	 */
	public synchronized void stop() {
		if (thread != null) {
			log("Stop: setting done = true");
			done = true;
			
			log("Stop: Joining thread...");
			try {
				thread.join();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			log("Stop: Thread joined...");
			thread = null; // was causing RemoteIntersectionManager to crash 
			log("Stop: thread stopped.");
		} else
			log("Stop: WARNING: already stopped.");
	}
	
	/**
	 * The maximum turn angle should be throttled based on the 
	 * divergence of the blob from the center.  A large divergence indicates the
	 * need for a large turn angle and vice-versa.
	 * Since the robot is programmed to move faster when the
	 * divergence is lower, this effectively dampens the robot's 
	 * turn rate when it is moving faster, thus achieving greater
	 * stability.  Without this, the robot would have a tendency to 
	 * swerve side-to-side as it increases in speed. 
	 * 
	 * @param divergencePct The percent divergence.
	 * @return The maximum turn angle.
	 */
	private double getMaxTurnAngle(double divergencePct) {
		log("getMaxTurnAgle: " + divergencePct);
		if (divergencePct < .10)
			return MAX_TURN_ANGLE * 0.1;
		if (divergencePct < .20)
			return MAX_TURN_ANGLE * 0.2;
		if (divergencePct < .30)
			return MAX_TURN_ANGLE * 0.3;
		if (divergencePct < .40)
			return MAX_TURN_ANGLE * 0.4;
		if (divergencePct < .50)
			return MAX_TURN_ANGLE * 0.6;
		if (divergencePct < .60)
			return MAX_TURN_ANGLE * 0.85;
		return MAX_TURN_ANGLE;
	}
	
	/**
	 * Adjusts the heading and speed of the robot based on the position of the blob.
	 * 
	 * @param blob The blob to use to calculate the heading of the robot.
	 * @param midPoint The middle of the field of view.
	 */
	private void adjustHeadingAndSpeed(PlayerBlobfinderBlob blob, int midPoint) {
		log("adjustHeadingAndSpeed: Blob area=" + blob.getArea() + ", color=" + blob.getColor() + ", left=" + blob.getLeft() + ", right=" + blob.getRight() + ", x=" + blob.getX());

		int turnSign;		
		if (blob.getX() > midPoint) {
			log("adjustHeadingAndSpeed: Center of blob is right of midpoint, must turn right!");
			turnSign = -1;
		} else {
			log("adjustHeadingAndSpeed: Center of blob is left of midpoint, must turn left!");
			turnSign = 1;
		}

		// Make the angle adjustment proportional to the degree to which the heading has diverged
		// from being perfectly centered on the line.
		// A divergencePct of 1 means the robot is the most off in terms of following the line.
		// A divergencePct of 0 means that the robot is perfectly centered on the line.
		double divergence = Math.abs(blob.getX() - midPoint);  // blob.getX() returns the centroid's X coordinate
		double divergencePct = divergence / midPoint;
		log("adjustHeadingAndSpeed: divergencePct = " + divergencePct);
		
		
		angle = turnSign * getMaxTurnAngle(divergencePct) * divergencePct;

		// Make the speed proportional to the degree to which the heading is off. 
		speed = MAX_SPEED * (1 - divergencePct);
		if (speed < MIN_SPEED)
			speed = MIN_SPEED;
	}
	
	/**
	 * The secondary blob is used for indicating three things: 
	 * 
	 * APPROACHING_INTERSECTION: secondary blob right of line
	 * ENTERING_INTERSECTION: secondary blob left of line
	 * EXITING_INTERSECTION: secondary blob crossing line
	 * 
	 * @param blob
	 */
	private void handleSecondaryBlob(PlayerBlobfinderBlob primary, PlayerBlobfinderBlob secondary) {
		// TODO: Add logic that determines the type of event that was detected.
		// One the type of event is determined, broadcast it to all registered listeners
		// Here's an example of how to broadcast an APPROACHING event.
		log("handleSecondaryBlob: area=" + secondary.getArea() + ", primary x=" + primary.getX() + ", secondary x=" + secondary.getX() + ", blob width=" + (Math.abs(secondary.getLeft()-secondary.getRight())) + ", previousEventType= " + previousEventType);
		
		if ((primary.getX() < secondary.getX()) && (Math.abs(secondary.getLeft() - secondary.getRight()) < 80)) {
			if (previousEventType == null || previousEventType  != LineFollowerEvent.LineFollowerEventType.APPROACHING) {
				log("handleSecondaryBlob: APPROACHING Intersection!");
				previousEventType = LineFollowerEvent.LineFollowerEventType.APPROACHING;
				LineFollowerEvent lfe = new LineFollowerEvent(LineFollowerEvent.LineFollowerEventType.APPROACHING);
				notifyListeners(lfe);
			} else
				log("handleSecondaryBlob: Supressing duplicate APPROACHING event");
		}
		else if ((primary.getX() > secondary.getX()) && (Math.abs(secondary.getLeft() - secondary.getRight()) < 80)) { 
			if (previousEventType == null || previousEventType  != LineFollowerEvent.LineFollowerEventType.ENTERING) {
				log("handleSecondaryBlob: ENTERING Intersection!");
				previousEventType = LineFollowerEvent.LineFollowerEventType.ENTERING;
				LineFollowerEvent lfe = new LineFollowerEvent(LineFollowerEvent.LineFollowerEventType.ENTERING);
				notifyListeners(lfe);
			} else
				log("handleSecondaryBlob: Supressing duplicate ENTERING Intersection event");
		}
		else if ((Math.abs(secondary.getLeft() - secondary.getRight()) > 100)) {
			if (previousEventType == null || previousEventType  != LineFollowerEvent.LineFollowerEventType.EXITING) {
				log("handleSecondaryBlob: EXITING Intersection!");
				previousEventType = LineFollowerEvent.LineFollowerEventType.EXITING;
				LineFollowerEvent lfe = new LineFollowerEvent(LineFollowerEvent.LineFollowerEventType.EXITING);
				notifyListeners(lfe);
			} else
				log("handleSecondaryBlob: Supressing duplicate EXITING Intersection event");
		}
	}

	/**
	 * Processes the blobs being reported by the CMUCam2.  There are two blobs.  The first one
	 * is a black blob that guides the robot so it stays on the lane.  The second blob is
	 * a blue one that indicates when the robot is approaching, entering and exiting the intersection.
	 * 
	 * @param data The blob finder data that contains information about all of the blobs in the
	 * current field of view.
	 */
	private void processBlobs(PlayerBlobfinderData data) {
		// Check to make sure we have valid data...
		if (data != null) {
			int numBlobs = data.getBlobs_count();
			log("processBlobs: There are " + numBlobs + " blobs...");

			if(numBlobs > 0) {	
				PlayerBlobfinderBlob[] blobList = data.getBlobs();

				// All of the following checks should not be necessary.  They were added
				// to counter a null pointer exception being occasionally thrown.
				if(blobList != null && blobList.length > 0 && blobList[0] != null) {
					int midPoint = data.getWidth()/2;
					adjustHeadingAndSpeed(blobList[0], midPoint);
				} else {
					log("processBlobs: ERROR: No primary blob, stopping robot...");
					speed = angle = 0;
				}

				// Right now only designed for detection of blue secondary blob
				try {
					if(blobList != null && numBlobs > 1 && blobList[1] != null) {
						handleSecondaryBlob(blobList[0], blobList[1]);
					} 
					else {
						log("processBlobs: No secondary blob!");
						previousEventType = null;
					}
				} catch(ArrayIndexOutOfBoundsException e) {
					// TODO Figure out why this sometimes happens.
					log("processBlobs: got an unexpected ArrayIndexOutOfBoundsException: " + e.getMessage());
					previousEventType = null;
				}
			}
			else {
				log("processBlobs: ERROR: No blobs present, stopping robot...");
				speed = angle = 0;
			}
		} else {
			log("processBlobs: ERROR: Blob data is null, stopping robot...");
			speed = angle = 0;
		}
	}
	
	/**
	 * This contains the main loop of the LineFollower thread.
	 */
	public void run() {
		long dataTimeStamp = 0;
		
		while(!done) {
			
			// If new blob data is available, get it and process it.
			if (bfi.isDataReady()) {
				dataTimeStamp = System.currentTimeMillis();
				processBlobs(bfi.getData());
			}
			
			// If no blob data is received within a certain time window, stop the robot.
			if (System.currentTimeMillis() - dataTimeStamp > BLOB_MAX_VALID_AGE) {
				log("run: ERROR: No blob data within valid window of " + BLOB_MAX_VALID_AGE + "ms");
				speed = angle = 0;
			}
			
			log("run: Sending Command, speed=" + speed + ", angle=" + angle);
			p2di.setSpeed(speed, dtor(angle));
			
			pause(CYCLE_PERIOD);
		}
		
		log("run: thread exiting, ensuring robot is stopped...");
		speed = angle = 0;
		p2di.setSpeed(speed, dtor(angle));
	}
	
	/**
	 * Converts degrees to radians.
	 * 
	 * @param degrees The angle in degrees.
	 * @return The angle in radians.
	 */
	private double dtor(double degrees) {
		double radians = degrees * (Math.PI / 180);
		return radians;
	}

	private void pause(int duration) {
		synchronized(this) {
			try {
				wait(duration);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
	
	/**
	 * Logs a debug message.  This message is only printed when debug mode is enabled.
	 * 
	 * @param msg The message to log.
	 */
	private void log(String msg) {
		log(msg, true);
	}
	
	/**
	 * Logs a message.
	 * 
	 * @param msg  The message to log.
	 * @param isDebugMsg Whether the message is a debug message.
	 */
	private void log(String msg, boolean isDebugMsg) {
		String result = "LineFollower: " + msg;
		if (!isDebugMsg || System.getProperty ("PharosMiddleware.debug") != null)
			System.out.println(result);
		if (flogger != null)
			flogger.log(result);
	}
}