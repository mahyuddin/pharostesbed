package pharoslabut.demo.autoIntersection;

import java.util.Enumeration;
import java.util.Vector;

import pharoslabut.demo.autoIntersection.IntersectionEvent.IntersectionEventType;
import pharoslabut.logger.Logger;
import pharoslabut.sensors.BlobDataConsumer;
import playerclient3.structures.blobfinder.PlayerBlobfinderBlob;
import playerclient3.structures.blobfinder.PlayerBlobfinderData;

/**
 * Analyzes blob data from the CMUCam2 to detect when the robot is approaching,
 * entering, and leaving the intersection.
 * 
 * @author Chien-Liang Fok
 */
public class IntersectionDetector implements BlobDataConsumer {
	
	/**
	 * Keeps track of whether an event for the secondary blob was already generated.
	 * Prevents many secondary blob events from being generated by a single secondary
	 * blob.
	 */
	private IntersectionEventType previousEventType = null;
	
	/**
	 * The listeners of intersection events.
	 */
	private Vector<IntersectionEventListener> listeners = new Vector<IntersectionEventListener>();
	
	/**
	 * The constructor.
	 */
	public IntersectionDetector() {
		
	}
	
	/**
	 * Adds a IntersectionEventListener to this object.
	 * 
	 * @param listener the IntersectionEventListener to add.
	 */
	public void addListener(IntersectionEventListener listener) {
		listeners.add(listener);
	}
	
	/**
	 * Removes a IntersectionEventListener from this object.
	 * 
	 * @param listener the IntersectionEventListener to remove.
	 */
	public void removeListener(IntersectionEventListener listener) {
		listeners.remove(listener);
	}
	
	/**
	 * Broadcasts the LineFollowerEvent a to all registered listeners.
	 * 
	 * @param ie The event to broadcast.
	 */
	private void notifyListeners(final IntersectionEvent ie) {
		Logger.log("Notifying listeners of new IntersectionEvent: " + ie);
		Enumeration<IntersectionEventListener> e = listeners.elements();
		while(e.hasMoreElements()) {
			final IntersectionEventListener lfel = e.nextElement();
			new Thread(new Runnable() {
				public void run () {
					lfel.newIntersectionEvent(ie);
				}
			}).start();
		}
	}
	
	/**
	 * The secondary blob is used for indicating three things: 
	 * 
	 * APPROACHING_INTERSECTION: secondary blob right of line
	 * ENTERING_INTERSECTION: secondary blob left of line
	 * EXITING_INTERSECTION: secondary blob crossing line
	 * 
	 * @param blob
	 */
	private void handleSecondaryBlob(PlayerBlobfinderBlob primary, PlayerBlobfinderBlob secondary) {
		// TODO: Add logic that determines the type of event that was detected.
		// One the type of event is determined, broadcast it to all registered listeners
		// Here's an example of how to broadcast an APPROACHING event.
		Logger.log("area=" + secondary.getArea() + ", primary x=" + primary.getX() + ", secondary x=" + secondary.getX() 
				+ ", blob width=" + (Math.abs(secondary.getLeft()-secondary.getRight())) + ", previousEventType= " + previousEventType);
		
		if ((primary.getX() < secondary.getX()) && (Math.abs(secondary.getLeft() - secondary.getRight()) < 80)) {
			if (previousEventType == null || previousEventType  != IntersectionEventType.APPROACHING) {
				Logger.log("APPROACHING Intersection!");
				previousEventType = IntersectionEventType.APPROACHING;
				IntersectionEvent lfe = new IntersectionEvent(IntersectionEventType.APPROACHING);
				notifyListeners(lfe);
			} else
				Logger.log("Supressing duplicate APPROACHING event");
		}
		else if ((primary.getX() > secondary.getX()) && (Math.abs(secondary.getLeft() - secondary.getRight()) < 80)) { 
			if (previousEventType == null || previousEventType  != IntersectionEventType.ENTERING) {
				Logger.log("ENTERING Intersection!");
				previousEventType = IntersectionEventType.ENTERING;
				IntersectionEvent lfe = new IntersectionEvent(IntersectionEventType.ENTERING);
				notifyListeners(lfe);
			} else
				Logger.log("Supressing duplicate ENTERING Intersection event");
		}
		else if ((Math.abs(secondary.getLeft() - secondary.getRight()) > 100)) {
			if (previousEventType == null || previousEventType  != IntersectionEventType.EXITING) {
				Logger.log("EXITING Intersection!");
				previousEventType = IntersectionEventType.EXITING;
				IntersectionEvent lfe = new IntersectionEvent(IntersectionEventType.EXITING);
				notifyListeners(lfe);
			} else
				Logger.log("Supressing duplicate EXITING Intersection event");
		}
	}

	@Override
	public void newBlobData(PlayerBlobfinderData data) {
		// Check to make sure we have valid data...
		if (data != null) {
			int numBlobs = data.getBlobs_count();
			Logger.log("There are " + numBlobs + " blobs...");

			PlayerBlobfinderBlob[] blobList = data.getBlobs();
				
			// Right now only designed for detection of blue secondary blob
			try {
				if(blobList != null && numBlobs > 1 && blobList[1] != null) {
					handleSecondaryBlob(blobList[0], blobList[1]);
				} 
				else {
					Logger.log("No secondary blob!");
					previousEventType = null;
				}
			} catch(ArrayIndexOutOfBoundsException e) {
				// TODO Figure out why this sometimes happens.
				Logger.logErr("got an unexpected ArrayIndexOutOfBoundsException: " + e.getMessage());
				previousEventType = null;
			}
			
		} else {
			Logger.logErr("Blob data is null, not performing intersection detection...");
		}		
	}
}
